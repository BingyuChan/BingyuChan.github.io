{"meta":{"title":"My Blog","subtitle":"","description":"","author":"BingyuChan","url":"https://BingyuChan.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2021-01-05T09:45:08.148Z","updated":"2021-01-03T15:27:44.457Z","comments":false,"path":"repository/index.html","permalink":"https://bingyuchan.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode刷题笔记","slug":"leetcode刷题笔记","date":"2021-01-27T02:21:11.000Z","updated":"2021-01-27T02:35:04.941Z","comments":true,"path":"2021/01/27/leetcode刷题笔记/","link":"","permalink":"https://bingyuchan.github.io/2021/01/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"剑指Offer 13.机器人运动范围题目描述地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 解题思路搜索&amp;回溯 DFS/BFS根据可达解的结构和连通性，可推出机器人仅向右和向下移动，即可访问所有可达解 方法一：深度优先遍历DFS- **深度优先搜索：** 暴力模拟机器人所有路径。DFS通过递归，先朝一个方向搜索到底，再回溯至上个节点，再沿另一个方向搜索，以此类推。 - **可行性剪枝：** 搜索中，遇到位数和超出目标值、该元素已访问，则立即返回。 算法解析： - 递归参数： 当前元素在矩阵中的行列索引i和j，两者的数位和si，sj。 - 终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值k 或 ③ 当前元素已访问 返回0，代表不可达。 - 递推工作： 1. 标记当前单元格： 将索引(i,j)存入Setvisited中，代表此单元格已被访问。 2. 搜索下一单元格： 计算当前元素下、右两个方向元素的数位和，并开启下层递归。 - 回溯返回值： 返回1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。题解 1","categories":[],"tags":[]},{"title":"Java面试指南","slug":"Java面试指南","date":"2021-01-21T02:41:45.000Z","updated":"2021-01-27T01:40:26.558Z","comments":true,"path":"2021/01/21/Java面试指南/","link":"","permalink":"https://bingyuchan.github.io/2021/01/21/Java%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/","excerpt":"","text":"面试基础面向对象和面向过程的区别 面向过程：性能更好。因为类调用需要实例化，开销大，比较消耗资源。所以当性能为最重要的考量因素时，比如单片机、嵌入式、Linux/Unix等，一般采用面向对象。但不如面向对象更易复用、易扩展、易维护。 面向对象：易复用、易扩展、易维护。因为面向对象有封装、继承、多态等特性，可设计出低耦合的系统，使系统更灵活、更易维护。 Java语言有何特点？ 面向对象（封装、继承、多态） 平台无关（JVM） 可靠性 安全性 支持多线程（Java语言提供多线程支持；C++语言没内置多线程机制，需调用操作系统多线程功能来进行多线程程序的设计） 编译解释并存 Java和JavaScript区别？ 不同公司，Java原Sun公司开发； Java 前身Oak，JS前身LiveScript； Java面向对象，JS基于对象和事件驱动； Java执行前需编译，JS解释运行； Java强类型变量检查，变量编译前必须声明，JS弱类型变量检查，变量使用前可不作声明； 字符型常量和字符串型常量的区别？ 形式上：字符型常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符。 含义上：字符型常量相当于一个整型值(ASCII值)，可参加表达式运算；字符串型常量代表一个地址(该字符串在内存中存放的地址) 占内存大小：字符型2个字节，字符串型若干个字节 形参与实参一、形参用来接收调用方法时传递的参数，被调用时分配内存，调用结束内存回收，仅在此方法内有效 123456# a,b是形参，方法结束时，在栈空间被销毁public void swap(int a ,innt b)&#123; int temp &#x3D; a; a &#x3D; b; b &#x3D; temp;&#125; 二、实参调用上面方法swap(6,8)，6 8就是实参 值传递和引用传递 值传递：方法调用时，实参传值给形参，函数收到的是原始值的副本。此时内存中存在两个相同的基本类型，方法对形参执行处理，不会影响实参的值。 引用传递：方法调用时，实参传引用（实参的内存地址）给形参，函数接受到的是原始值的内存地址，方法中，形参和实参的内容（地址）相同，方法对形参的处理会影响实参的值。 Java8新特性支持函数式编程，新的JavaScript引擎，新的日期API，新的Stream API等。Lambda表达式、方法引用、默认方法、新工具、Stream API、Date Time API、Optional类、Nashorn、JavaScript引擎。https://www.runoob.com/java/java8-new-features.html Lambda表达式优点优： 简洁； 便于用于并行计算；缺： 若不用于并行，效率不如for； 不易调试； 锁机制悲观锁适用于写多的场景先取锁再访问，总是假设最坏的情况，每次读取数据时默认其他线程会更改数据。分共享锁和排他锁。 共享锁(读锁)：多个事务对同一数据共享一把锁，都能访问，只读不可修改； 排他锁(写锁)：一个事务获取一个数据行的排他锁，其他事务不能获取该行其他锁，排他锁对数据可读可改。具体实现（依靠数据库的锁机制）： 对记录改前先加排他锁； 若加锁失败，继续等待或抛异常； 加锁成功，对数据进行修改，事务完成后解锁； 期间若其他事务妄图对该数据加锁，则suspend或抛异常。mysql中InnoDB，时用悲观锁时需关闭autocommit（set autocommit=0），否则执行一个更新后立刻提交。1234begin;&#x2F;&#x2F;0.开始事务select quantity from items where id&#x3D;1 for update;&#x2F;&#x2F;1.查询库存，for update加锁update items set quantity&#x3D;2 where id&#x3D;1;&#x2F;&#x2F;2.修改库存commit;&#x2F;&#x2F;3.提交事务 *InnoDB默认行级锁，行级锁基于索引，若SQL语句用不到索引，不会使用行级锁，会使用表级锁，将整张表锁住。 乐观锁（适用于多写场景）线程提交前根据版本进行冲突检测。冲突检测、数据更新。版本号控制：数据表中加version字段，当数据被修改时+1。 123#CAS（compare and swap）select quantity from items where id&#x3D;1;&#x2F;&#x2F;1.查询库存，quantity&#x3D;3update items set quantity&#x3D;2 where id&#x3D;1 and quantity&#x3D;3;&#x2F;&#x2F;2.修改为2 *会出现ABA问题；线程1、2同时取，库存都为3，thread 1将库存改为2，thread 2将库存改为3，判定thread 1CAS成功。解决ABA，需加version字段。高并发下，需更改乐观锁粒度，提高吞吐率。 IO包 InputStream、OutputStream、Reader、Writer 4个抽象类派生 文件File、管道Piped、缓冲Buffered、对象化序列Object、基本数据类型Data、转化控制InputStreamReader/OutputStreamWriter、数组Byte/Char、打印Print 有字节流后为何还要字符流？ANS：字符流是由Java虚拟机将字节转换而来，过程非常耗时、若不知道编码类型更容易出现乱码。故I/O提供操作字符的接口。音频、图片等媒体文件用字节流；字符等用字符流。 BIO，NIO，AIO区别BIO（Blocking I/O）同步阻塞I/O，数据读写必须阻塞在一个线程。简单；性能和可靠性不好，适合低负载、低并发。NIO（Non-blocking/New I/O）同步非阻塞I/O，Java 1.4中引入。支持面向缓冲的、基于通道的I/O，适合高负载、高并发。AIO（Asynchronous I/O）Java 7中引入，异步非阻塞。 同步、异步、阻塞、非阻塞IO总结同步/异步IO主要是访问数据的机制（实际I/O操作的完成方式）同步一般指主动请求并等待I/O操作完毕的方式，I/O操作未完成前，会导致应用进程挂起；异步指用户进程触发IO操作后就做自己的事情去了，当IO操作完成时会得到IO完成的通知（异步的特点就是通知），这使得进程在读写时也不阻塞。阻塞/非阻塞IO主要指IO操作第一阶段的完成方式，进程访问的数据如果尚未就绪（即数据还未准备好的时候），应用进程的表现。如果进程挂起，则为阻塞IO。否则为非阻塞IO。说白了阻塞/非阻塞是针对于进程访问数据的时候，根据IO操作的就需状态来采取的不同方式，也就诗一种读取或写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或写入函数会立即返回一个状态值。 自增变量1234567public static void main(String[] args)&#123; int i&#x3D;1; i&#x3D;i++; int j&#x3D;i++; int k&#x3D;i + ++i * i++; 输出 i,j,k&#125; i=4，j=1，k=11 hashCode()作用：获取哈希码，也称散列码，返回的是一个int整数，进而确定该对象在哈希表中的索引位置。 哈希冲突概念：不同数据，得到的哈希值相同解决： 开放地址法（再散列法） 线性探查法 平方探查法 双散列函数探查法 链地址法（拉链法） 再哈希法 创建公共溢出区 覆盖equals()为什么要覆盖hashCode() 若无需创建类对应的散列表，则hashCode和equals无关 创建了类对应的散列表后，重写equals必须重写hashCode把对象加入hashSet的时，hashSet会先计算对象的hashCode值，来判断对象要加入的位置。同时，也会将该位置其他已加入对象的hashCode拿出来比较，如果没有相符的hashCode，hashSet会假设对象没有重复出现。如果发现了相同的hashCode，会调用equals检查对象是否真的相同。如果相同，则不插入；如果不同，则散列到其他位置（hash冲突）123456789# 创建类的散列表Person p1 &#x3D; new Person(&quot;eee&quot;, 100);Person p2 &#x3D; new Person(&quot;eee&quot;, 100);Person p3 &#x3D; new Person(&quot;aaa&quot;, 200);&#x2F;&#x2F; 新建HashSet对象 HashSet set &#x3D; new HashSet();set.add(p1);set.add(p2);set.add(p3); 1234567891011121314151617181920212223# 重写hashCode@Overridepublic int hashCode()&#123; int nameHash &#x3D; name.toUpperCase().hashCode(); return nameHash ^ age;&#125;#重写equals@Overridepublic boolean equals(Object obj)&#123; if(obj &#x3D;&#x3D; null)&#123; return false; &#125; &#x2F;&#x2F;如果是同一个对象返回true，反之返回false if(this &#x3D;&#x3D; obj)&#123; return true;&#125; &#x2F;&#x2F;判断是否类型相同 if(this.getClass() !&#x3D; obj.getClass())&#123; return false; &#125; Person person &#x3D; (Person)obj; return name.equals(person.name) &amp;&amp; age&#x3D;&#x3D;person.age; &#125; Java为什么要定义一个无参构造方法Java执行子类构造方法之前，若子类没有用super()调用父类特定构造方法，会默认调用父类无参构造，此时父类若没有无参构造，则会编译错误。 String StringBuffer 和 StringBuilder区别？String为何不可变？1. String为何不可变？String类中使用final关键字修饰字符数组，来保存字符串的。private final char value[] 2. 异同点StringBuffer与StringBuilder都继承于AbstractStringBuilder，有相同父类 线程安全性String中对象不可变，可理解为常量，线程安全。AbstractStringBuilder是StringBuffer和StringBuilder公共父类，定义了一些字符串的基本操作，如extendCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加同步锁，线程安全；StringBuilder无锁，非线程安全。 性能每次对String类型进行改变时，都会new一个新String对象，再改变对象的引用，指向新String对象；StringBuffer每次都会对StringBuffer本身进行操作；相同情况下，StringBuilder会有略微性能提升，但要冒多线程不安全的风险。 总结 少量数据的操作：String 单线程操作字符串，缓冲区下操作大量数据：StringBuilder 多线程操作字符串，缓冲区下操作大量数据：StringBuffer 数据结构与算法树二叉树二叉树（binary tree）是指树中节点的度不大于2的有序树 二叉查找树左子树的键值小于根的键值，右子树的键值大于根的键值 平衡二叉树（AVL Tree）平衡二叉树（AVL 树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为 1。 平衡多路查找树（B-Tree）B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K。 数据库常见四种引擎 InnoDB MyISAM MEMORY ArchiveACID1. 原子性（atomicity)一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作。2. 一致性（consistency)事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态3. 隔离性（isolation）事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。4. 持久性（durability）一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。","categories":[],"tags":[]},{"title":"JVM","slug":"JVM","date":"2021-01-20T06:50:55.000Z","updated":"2021-01-26T06:10:10.349Z","comments":true,"path":"2021/01/20/JVM/","link":"","permalink":"https://bingyuchan.github.io/2021/01/20/JVM/","excerpt":"","text":"JVMJVM是运行Java字节码的虚拟机。 Java程序从源码到运行一般有以下3步：.java文件(源码) –&gt; .class文件(JVM可理解的Java字节) –&gt; 机器可执行的二进制机器码 类加载器分几种？引导类加载器、自定义加载器（扩展类加载器、系统类加载器、用户自定义加载器）继承于ClassLoader。 如何看待？相互间关系？双亲委派机制？沙箱模型？每个阶段都做什么？垃圾回收机制（算法）？各垃圾回收器特点与区别？各种JVMSun Classic VM –&gt; 解释型HotSpot VM（Sun公司） 面试默认BEA的JRockit –&gt; 不含解释器，运行于服务器端，JMCIBM的J9Graal VM –&gt; 2018年。Run Programs Faster Anywhere 类加载过程？分为加载阶段、链接阶段、初始化阶段。 加载阶段引导类加载器、扩展类加载器、系统类加载器.class文件通过类加载器，以二进制流的方式加载到JVM方法区（jdk7以前称永久带，jdk8及以后称元空间）在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 链接阶段验证（verify）、准备（prepare）、解析（resolve） 初始化阶段初始化其实就是执行()方法的过程类中有静态变量或静态代码块时调用()方法虚拟机会保证()方法在多线程下被同步加锁，即一个类只被加载一次 类加载器引导类加载器、自定义类加载器","categories":[],"tags":[]},{"title":"Redis集群搭建(Linux)","slug":"Redis集群搭建-Linux","date":"2021-01-18T05:09:22.000Z","updated":"2021-01-18T09:22:25.162Z","comments":true,"path":"2021/01/18/Redis集群搭建-Linux/","link":"","permalink":"https://bingyuchan.github.io/2021/01/18/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA-Linux/","excerpt":"","text":"单机搭建1. 环境配置查看服务器是否安装gccgcc -v若无gcc，则执行以下指令yum install gcc-c++ 2. Redis安装步骤2.1 Mac上传Redis压缩包至服务器cd downloads scp redis-6.0.10.tar.gz root@101.37.157.4:/root/redis 2.2 解压tar zxf redis-6.0.10.tar.gz 2.3 make进入redis目录查看是否有makefile文件若有，直接使用make指令若make失败，失败如下In file included from server.c:30:0: server.h:1082:5: error: expected specifier-qualifier-list before &#39;_Atomic&#39; _Atomic unsigned int lruclock; /* Clock for LRU eviction */判断可能是gcc版本太低，redis6.0以上需gcc5以上版本 12345678gcc -v &#x2F;&#x2F;查看版本make distclean &#x2F;&#x2F;清除上次编译失败残留文件# 安装centos-release-sclsudo yum install centos-release-scl# 安装gcc 8.*版本sudo yum install devtoolset-8-gcc*# 激活对应的devtoolsetscl enable devtoolset-8 bash 安装成功后再次执行make指令即可安装编译后的redis代码到指定目录，一般存放于/usr/local/redis目录cd /root/redis/redis-6.0.10/srcmake install PREFIX=/usr/local/redis 2.4 查看redis版本cd /usr/local/redis/bin./redis-server -v 2.5 启动redis 前台启动cd /usr/local/redis/bin./redis-server 后台启动1234561. 将redis解压文件里的redis.conf复制到当前bin目录cp &#x2F;root&#x2F;redis&#x2F;redis-6.0.10&#x2F;redis.conf .2. 修改redis.conf文件。将daemonize no -&gt; daemonize yesvim redis.conf3. 后台启动redis.&#x2F;redis-server redis.conf 2.6 查看redis是否运行ps aux | grep redis 2.7 打开redis连接./redis-cli 2.8 将连接到其他端口./redis-cli -h 101.37.157.4 -p 6379","categories":[],"tags":[]},{"title":"miaosha","slug":"miaosha","date":"2021-01-07T02:16:04.000Z","updated":"2021-01-07T02:17:37.643Z","comments":true,"path":"2021/01/07/miaosha/","link":"","permalink":"https://bingyuchan.github.io/2021/01/07/miaosha/","excerpt":"","text":"秒杀系统一、学习目标 了解秒杀的业务 掌握秒杀的设计思路及技术架构 掌握SpringCloud针对于秒杀业务的应用 掌握redis对于性能的提升作用 掌握RabbitMQ对于业务拆分异步的处理应用 二、了解秒杀的业务及使用的技术架构2.1. 什么是秒杀【秒杀】一词在网络的最早起源，应该要追溯到日本的综合格斗技团体Pancrase在1993年9月21日发行的WEEKLY PRO-WRESTLING（每周职业摔跤）杂志中出现的自创词，在2000年发行的一款回合制网络游戏【石器时代】传入中国并被发扬光大。 【石器时代】在战斗时会出现【合击】现象，就算大家敏捷素质不同，在倒计时28秒时，同时选择攻击一个目标，也会极大概率发动攻击群殴一个目标。特别是在玩家的PK战，经常出现群体合击或者人宠合击，造成强大的杀伤，瞬间打飞或者打晕对手。 由于游戏战斗采用的是倒计时模式，强大的杀伤往往只在一秒没过就结束，所以这类瞬间或几下击败对手就被称作：【秒杀】 到后来演化渐变成通俗用语，甚至用来替代一些暴力词汇： “小心我秒你”；“昨天PK遇到高手，我被秒了”；“lj快走，不然秒你”；“终于120级，转生可以秒机暴啦”等等。 并在之后的【传奇】【MU】【CS】等各种经典游戏中广为流传。直至被商家促销活动所用。 所谓“秒杀”，是网上竞拍的一种新方式，就是网络卖家发布一些超低价格的商品，所有买家在同一时间网上抢购的一种销售方式。通俗一点讲就是网络商家为促销等目的组织的网上限时抢购活动。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。2011年以来，在淘宝等大型购物网站中，“秒杀店”的发展可谓迅猛。 对于商家来说，按照商家的规模，秒杀分为三种形式： 1、平台要求准时准点做秒杀，类似于天猫双11，11月11日0点开始抢购，或者京东的整点抢购，都由平台发起。 2、商家对于自己的店铺做秒杀，一般是厂家的旗舰店，在平台首页占据有利广告位，进入店铺做秒杀。 3、微信公众号链接网页做秒杀，由公众号运营的商家发起。 按照商家的促销活动内容，秒杀分为三种方式： 1、限价秒杀：最常见的秒杀形式，秒杀价格绝对低到令人无法相信也无法抗拒而不去参与，此种秒杀一般在开始之后1-3秒之内就会秒杀完毕。 2、低价限量秒杀：此种形式也可以理解为低折扣秒杀，限量不限时，秒完即止，此种秒杀形式商家提供一定数量的商品，直至秒完即止。 3、低价限时限量秒杀：此种形式也可以理解为低折扣秒杀，限时限量，在规定的时间内，无论商品是否秒杀完毕，该场秒杀都会结束。 2.2. 秒杀的业务特点1、瞬时并发量大：大量用户会在同一时间抢购，网站流量瞬间激增。 2、库存少：一般都是低价限量，而访问的数量远远大于库存数量，只有极少数人成功。 3、业务流程简单：流程短，立即购买，下订单，减库存。 4、前期预热：对于还未开启活动的秒杀商品，以倒计时的方式显示，只能访问不能下单。 2.3. 设计思路 1、限流：只能让秒杀成功的一小部分人进入到后台，和数据库进行交互，来减少数据库服务器的压力。 2、缓存：将部分业务逻辑写到缓存里，例如：商品限购数量、秒杀政策等。 3、异步：将业务逻辑拆分，减少服务器压力，例如：正常业务流程是下订单、付款、减库存同一时间完成，秒杀时可以将业务逻辑拆分。 4、预热：商家进行宣传，并提前设置好秒杀的商品、秒杀时间、限购数量，将设置的商品写入 redis 缓存。 5、展示：页面分为两层，第一层是商品列表页，第二层是商品详情页，通过商品列表页链接进入商品详情页，秒杀开始前，展示商品秒杀倒计时，不允许操作提交订单，只允许查看商品详情。秒杀开始时，展示商品秒杀到期时间。 6、提交订单：秒杀提交完订单将 redis 缓存里的数量减少，并提示支付。 7、队列操作：当支付成功之后，将秒杀成功详情写入 rabbitMQ，订单服务进行监听接收消息写入订单，库存服务进行监听接收消息减少库存。 8、时间服务器：页面服务端通过负载进行布署，各服务器时间可能会不一致，因此增加时间服务，来提供统一的时间。 2.4. 技术架构 整体架构图： Eureka Client： 时间服务（leyouTimeServer，端口号8000）：为页面服务提供时间统一的接口。 商品服务（leyouStock，端口号7000）：对外提供的接口（商品列表、商品详情、秒杀政策）。 库存服务（leyouStorage，端口号6001）：队列监听，在队列中提取消息与数据库交互减少库存。 会员服务（leyouUser，端口号5000）：为页面服务提供会员数据接口，会员的添加、修改、登录。 订单服务（leyouOrder，端口号4000）：队列监听，在队列中提取消息与数据库交互生成订单。 页面服务（leyouClient，端口号3000）：为前端页面提供数据接口。 Eureka Server： 注册中心（leyouServer，端口号9000）各服务都在注册中心进行注册。 配置中心 （leyouConfig）：提供所有服务需要的配置。 Redis的应用： 缓存商品数量、秒杀政策。 商家对秒杀政策、商品限量进行设置，设置完成写入Redis。 消费者访问商品详情，提交订单之后，从Redis中减少商品数量。 Redis里存取内容： 1、在政策新增的时候存入，key的值为：LIMIT_POLICY_{sku_id}，value的值为政策内容 2、商品列表取数据时，通过key（LIMIT_POLICY_{sku_id}），取出政策内容。 3、政策到期之后，自动删除。 RabbitMQ的应用： 消费者提交订单，自动写入订单队列： 订单队列：订单服务监听订单队列，接收到消息之后将队列信息写入数据库订单表。 消费者付款之后，更新订单状态，更新成功之后写入库存队列 库存队列：库存服务监听库存队列，接收到消息之后将库存信息写入数据库减少库存。 2.5. 数据库结构 三、秒杀环境搭建（了解）3.1. 安装redis及配置3.1.1. 安装redis 3.1.2. 配置redis安装完毕后，需要先做一些设定工作，以便服务启动后能正常运行。使用文本编辑器，这里使用Notepad++，打开Redis服务配置文件。注意：不要找错了，通常为redis.windows-service.conf，而不是redis.windows.conf。后者是以非系统服务方式启动程序使用的配置文件。 找到含有requirepass字样的地方，追加一行，输入requirepass leyou。这是访问Redis时所需的密码，后面在项目中也需要设置。 测试一下Redis是否正常提供服务。进入Redis的目录，cd C:\\Program Files\\Redis。输入redis-cli并回车。（redis-cli是客户端程序）如图正常提示进入，并显示正确端口号，则表示服务已经启动。 输入 auth leyou，显示OK，则密码正确。 实际测试一下读写。输入set mykey “abd”并回车，用来保存一个键值。再输入get mykey，获取刚才保存的键值。 开启持久化，appendonly yes –默认为no。 持久化：将数据（如内存中的对象）保存到可永久保存的存储设备中。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、 XML 数据文件中等等。 redis的数据都是缓存在内存中，当你重启系统或者关闭系统后，缓存在内存中的数据都会全部消失，再也找不回来了。所以为了让数据能够长期保存，就要将 Redis 放在缓存中的数据做持久化存储。 写入时机默认为everysec，每秒 也可以设置为always，实时写入，但是会有效率问题。 900秒有一个值存入，就持久化一次 300秒有10个值存入，就持久化一次 60秒有10000个值存入，就持久化一次 3.2. 安装RabbitMQ及配置3.2.1. 安装RabbitMQ客户端安装 otp_win64_20.2.exe 3.2.2. 安装RabbitMQ服务端安装 rabbitmq-server-3.7.4.exe 3.2.3. 配置RabbitMQ服务端 配置RabbitMQ客户端环境变量 配置RabbitMQ服务端环境变量 在环境变量中增加RabbitMQ服务端 安装插件：rabbitmq-plugins.bat enable rabbitmq_management 重启RabbitMQ服务 启动RabbitMQ 四、秒杀系统创建首先看一下秒杀的目录结构 4.1. 创建Eureka注册中心（端口号9000） 第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouServer，Description为Server For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Server，选择Next 第四步：Module name 为 leyouServer，Content root为路径+leyouServer，选择Finish，此时在项目文件夹下会创建一个 leyouServer文件夹 4.1.1. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 在右下角悬浮的窗口中点击 Import Changes，会自动到Maven远程仓库去下载所需要用到的jar包。 如果没有引入，可以根据下图，在IDEA右侧选择 Maven Projects，找到leyouServer选择 Dependencies右击，选择 Download Sources，也会去Maven远程仓库下载所需要用到的jar包，后面的所有项目都如此。 4.1.2. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 12345678server.port=9000eureka.client.service-url.defaultZone=http://localhost:9000/eureka/eureka.instance.hostname=localhostspring.application.name=leyou-server#不从服务器拿服务信息eureka.client.fetch-registry=false#不在服务端注册eureka.client.register-with-eureka=false 注意：这里的端口号后一定不能加入空格等字符，否则会报错 4.1.3. 编写启动类在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouServerApplication，在已经生成的启动类中加入 @EnableEurekaServer，意思为启动Eureka服务端 123456789@SpringBootApplication@EnableEurekaServerpublic class ServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServerApplication.class, args); &#125;&#125; 测试运行注册中心，在浏览器中输入 http://localhost:9000 到这里，注册中心服务完成。 4.2. 创建时间服务（端口号8000） 4.2.1. 创建时间服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouTimeServer，Description为TimeServer For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 leyouTimeServer，Content root为路径+leyouTimeServer，选择Finish，此时在项目文件夹下会创建一个 leyouTimeServer文件夹 在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouTimeServer&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 1234server.port=8000spring.application.name=leyou-time-servereureka.client.service-url.defaultZone=http://localhost:9000/eureka/ 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouTimeServerApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端 12345678910@SpringBootApplication@EnableEurekaClientpublic class TimeServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TimeServerApplication.class, args); &#125;&#125; 测试运行订单服务，在Eureka注册中心中可以看到 leyou-time-server服务，证明服务启动成功 4.2.2. 创建controller文件夹，并创建timeController.java文件给TimeController.java类增加注解 123@RestControllerpublic class timeController &#123;&#125; 4.2.3. 创建时间查询方法（getTime）用途：给前端秒杀提供统一的时间标准，在TimeController里写入如下代码： 12345@RequestMapping(value = &quot;/getTime&quot;)public String getTime()&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); return simpleDateFormat.format(new Date());&#125; 4.2.4. 测试时间查询直接通过页面访问 getTime 方法，然后得到当前时间，地址：http://localhost:8000/getTime 4.3. 创建商品服务（端口号7000） 4.3.1. 创建商品表结构（略）4.3.2. 创建商品服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouStock，Description为Stock For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 leyouStock，Content root为路径+leyouStock，选择Finish，此时在项目文件夹下会创建一个 leyouStock文件夹 4.3.3. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包（每个客户端必须要有这个依赖），利用alibaba的fastjson解析json数据，所以引入alibaba.fastjson用到的jar包，mysql-connector-java与spring-boot-starter-data-jpa依赖引入mysql连接使用的jar包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouStock&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 4.3.4. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 123456789101112131415161718192021222324252627server.port=7000spring.application.name=leyou-stockeureka.client.service-url.defaultZone=http://localhost:9000/eureka/spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/code1_2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root#redis数据库编号，存在0~15共16个数据库spring.redis.database=0#redis服务器IPspring.redis.host=127.0.0.1#redis端口号spring.redis.port=6379#redis密码spring.redis.password=leyou#redis请求超时时间，超过此值redis自动断开连接spring.redis.timeout=10000ms#jedis最大连接数，超过此值则提示获取不到连接异常spring.redis.jedis.pool.max-active=32#jedis最大等待时间，超过此值会提示连接超时异常spring.redis.jedis.pool.max-wait=10000ms#jedis最大等待连接数spring.redis.jedis.pool.max-idle=32#jedis最小等待连接数spring.redis.jedis.pool.min-idle=0 4.3.5. 编写启动类在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouStockApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端 123456789@SpringBootApplication@EnableEurekaClientpublic class StockApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StockApplication.class, args); &#125;&#125; 注意：这里如果 @EnableEurekaClient报错，那就证明依赖文件引入有误，比如：在依赖spring-cloud-starter-netflix-eureka-client后加个1，如下图： 会导致： 注意：一般会犯错的地方是 starter 写成 start，不容易看出来，可以到maven projects里去查看是否有错误 测试运行商品服务，在Eureka注册中心中可以看到 leyou-Stock服务，证明服务启动成功 4.3.6. 创建controller\\service\\dao文件夹，并创建StockController.java\\StockService.java\\StockDao.java文件Controller：管理业务（Service）调度和管理跳转 Service：管理具体功能、分支判断 Dao：管理数据交互，完成增删改查 Controller像是服务员，顾客点什么菜，在几号桌。 Service像是厨师，前端请求过来的菜单上的菜都是他做。 Dao像是厨房小工，原材料都是他来打交道。 4.3.7. 创建商品列表查询方法（getStockList）用途：为前端页面服务提供商品列表数据，主要用于前端商品列表页展示。 先约定好和前端交互返回的数据结构： 返回的json字符串： 如果返回值错误：{“result”:”false”, “msg”:”****”} 如果返回值正确：{“result”:”true”, “msg”:””, “sku_list”:[“id”:1,”sku_id”:…]} 先从Dao的方法开始编写代码： 创建Dao层接口文件，IStockDao 1public interface IStockDao &#123;&#125; 给StockDao.java类增加注解，@Repository用于标注数据访问组件，即DAO组件，实现IStockDao接口 12@Repositorypublic class StockDao implements IStockDao&#123;&#125; 声明 JDBCTemplate 方法，用于连接数据库使用 12@Autowiredprivate JdbcTemplate jdbcTemplate; 增加getStockList方法，首先从数据库中将商品列表所需要的数据查询出来，装入一个ArrayList变量中，原因是商品列表有多行数据，是一个列表，然后将ArrayList返回，代码如下： 123456789//1、创建一个SQLString sql = &quot;select id AS sku_id, title, images, stock, price, indexes, own_spec &quot; + &quot;from tb_sku&quot;;//2、执行这个SQLArrayList&lt;Map&lt;String, Object&gt;&gt; list = (ArrayList&lt;Map&lt;String, Object&gt;&gt;) jdbcTemplate.queryForList(sql);//3、返回数据return list; 再编写Service 创建Service层接口文件，IStockService 1public interface IStockService &#123;&#125; 给StockService.java增加注解，并实现IStockService接口 12@Servicepublic class StockService implements IStockService&#123;&#125; 加入IStockDao接口的引用 12@Autowiredprivate IStockDao iStockDao; 增加getStockList方法，调用StockDao中的getStockList，返回一个Map 123456789101112131415161718192021public Map&lt;String, Object&gt; getStockList()&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、取IstockDao的方法 ArrayList&lt;Map&lt;String, Object&gt;&gt; list = iStockDao.getStockList(); //2、如果没取出数据，返回错误信息 if (list==null||list.size()==0)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;我们也不知道为啥没取出数据！&quot;); return resultMap; &#125; //3、从redis里取数据 resultMap = getLimitPolicy(list); //4、返回正常信息 resultMap.put(&quot;sku_list&quot;, list);// resultMap.put(&quot;result&quot;, true);//// resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap; &#125; 注意：这里的Service有业务逻辑判断，当Dao返回数据后，如果数据为空，需要加入业务逻辑判断，未找到相应的商品信息，如果不加该判断，前端页面获取的数据为空，那么页面上会空白并且不显示任何数据，会给页面操作者带来不好的体验感，疑惑：是不是网络中断？或者服务器宕机？所以这里返回“未找到相应的商品信息”的提示，有助于页面友好的显示。前端的程序员也可以通过result参数判断 通过alt+回车，选择Create method ‘getStockList’，在IStockDao接口文件中自动创建接口的方法。 在IStockDao接口文件中给方法加上public修饰符， 给StockController.java类增加注解 12@RestControllerpublic class StockController &#123;&#125; 加入IStockService接口的引用 12@Autowiredprivate IStockService iStockService; 增加 getStockList 方法，调用StockService中的getStockList，返回的是一个Map，对于页面来说是得到一个Json字符串 1234@RequestMapping(value = &quot;/getStockList&quot;)public Map&lt;String, Object&gt; getStockList()&#123; return iStockService.getStockList();&#125; 测试getStockList方法，在浏览器中输入 http://localhost:7000/getStockList 4.3.8. 创建商品查询方法（getStock）用途：为前端页面服务提供商品详情页数据，主要用于前端商品详情页展示。 在StockDao.java类中增加 getStock方法，带一个sku_id参数，意思是通过sku_id进行查找，返回一个商品Map，代码如下： 12345678910111213//1、创建一个SQLString sql = &quot;select tb_sku.spu_id, tb_sku.title, tb_sku.images, tb_sku.stock, tb_sku.price, tb_sku.indexes, &quot; + &quot;tb_sku.own_spec, tb_sku.enable, tb_sku.create_time, tb_sku.update_time,tb_spu_detail.description,&quot; + &quot;tb_sku.id AS sku_id,tb_spu_detail.special_spec &quot; + &quot;from tb_sku &quot; + &quot;INNER JOIN tb_spu_detail ON tb_spu_detail.spu_id=tb_sku.spu_id &quot; + &quot;where tb_sku.id = ?&quot;;//2、执行这个SQLArrayList&lt;Map&lt;String, Object&gt;&gt; list = (ArrayList&lt;Map&lt;String, Object&gt;&gt;) jdbcTemplate.queryForList(sql, sku_id);//3、返回数据return list; 在StockService.java类中增加getStock方法，返回一个商品Map，代码如下： 1234567891011121314151617181920212223242526272829public Map&lt;String, Object&gt; getStock(String sku_id)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、传入参数 if (sku_id==null||sku_id.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;前端传过来的什么东东？&quot;); return resultMap; &#125; //2、取IstockDao的方法 ArrayList&lt;Map&lt;String, Object&gt;&gt; list = iStockDao.getStock(sku_id); //3、如果没取出数据，返回错误信息 if (list==null||list.size()==0)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;数据库咋回事，还取不出来数据了！&quot;); return resultMap; &#125; //3、从redis里取数据 resultMap = getLimitPolicy(list); //4、返回正常信息 resultMap.put(&quot;sku&quot;, list);// resultMap.put(&quot;result&quot;, true);// resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap; &#125; 注意：这里的Service有业务逻辑判断，如果传入参数为空时，会导致数据库查询报错，因此在传入Dao层之前进行判断，传入的参数是否合法。当Dao返回数据后，如果数据为空，也需要加入业务逻辑判断，未找到相应的商品信息 同时，在IStockDao中生成相对应的方法。 在StockController.java类中增加getStock方法，需要增加注解@RequestMapping，其中value = “/getStock/{sku_id}，返回一个商品Map，代码如下： 1234@RequestMapping(value = &quot;/getStock/&#123;sku_id&#125;&quot;)public Map&lt;String, Object&gt; getStock(@PathVariable(&quot;sku_id&quot;) String sku_id)&#123; return iStockService.getStock(sku_id);&#125; 测试getStock方法，在浏览器中输入localhost:7000/getStock/123 在浏览器中输入localhost:7000/getStock/26816294479 从redis里取值方法 12345678910111213141516171819202122232425262728293031323334353637private Map&lt;String, Object&gt; getLimitPolicy(ArrayList&lt;Map&lt;String, Object&gt;&gt; list)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); for (Map&lt;String, Object&gt; skuMap: list)&#123; //3.1、从redis取出政策 String policy = stringRedisTemplate.opsForValue().get(&quot;LIMIT_POLICY_&quot;+skuMap.get(&quot;sku_id&quot;).toString()); //3.2、判断有政策的才继续 if (policy!=null&amp;&amp;!policy.equals(&quot;&quot;))&#123; Map&lt;String, Object&gt; policyInfo = JSONObject.parseObject(policy, Map.class); //3.3、开始时间小于等于当前时间，并且当前时间小于等于结束时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); String now = restTemplate.getForObject(&quot;http://leyou-time-server/getTime&quot;, String.class); try &#123; Date end_time = simpleDateFormat.parse(policyInfo.get(&quot;end_time&quot;).toString()); Date begin_time = simpleDateFormat.parse(policyInfo.get(&quot;begin_time&quot;).toString()); Date now_time = simpleDateFormat.parse(now); if (begin_time.getTime()&lt;=now_time.getTime()&amp;&amp;now_time.getTime()&lt;=end_time.getTime())&#123; skuMap.put(&quot;limitPrice&quot;, policyInfo.get(&quot;price&quot;)); skuMap.put(&quot;limitQuanty&quot;, policyInfo.get(&quot;quanty&quot;)); skuMap.put(&quot;limitBeginTime&quot;, policyInfo.get(&quot;begin_time&quot;)); skuMap.put(&quot;limitEndTime&quot;, policyInfo.get(&quot;end_time&quot;)); skuMap.put(&quot;nowTime&quot;, now); &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 4.3.9. 秒杀政策表结构12345678910DROP TABLE IF EXISTS `tb_limit_policy`;CREATE TABLE `tb_limit_policy` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `sku_id` BIGINT(20) NOT NULL COMMENT &#x27;skuid&#x27;, `quanty` BIGINT(20) COMMENT &#x27;数量&#x27;, `price` BIGINT(20) COMMENT &#x27;秒杀价格&#x27;, `begin_time` TIMESTAMP COMMENT &#x27;开始时间&#x27;, `end_time` TIMESTAMP COMMENT &#x27;结束时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 4.3.10. 创建秒杀政策增加方法（insertLimitPolicy）用途：用于创建秒杀政策，并将政策写入 Redis 缓存。 在StockDao.java中增加一个insertLimitPolicy方法，带一个map参数，map里是前端页面传入的信息，返回一个boolean值 12345public boolean insertLimitPolicy(Map&lt;String, Object&gt; map)&#123; String sql = &quot;insert into tb_limit_policy (sku_id, quanty, price, begin_time, end_time) &quot; + &quot;Values (?, ?, ?, ?, ?)&quot;; return jdbcTemplate.update(sql, map.get(&quot;sku_id&quot;), map.get(&quot;quanty&quot;), map.get(&quot;price&quot;), map.get(&quot;begin_time&quot;), map.get(&quot;end_time&quot;))==1;&#125; 在StockService.java里增加一个insertLimitPolicy方法，返回一个map，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Transactionalpublic Map&lt;String, Object&gt; insertLimitPolicy(Map&lt;String, Object&gt; policyMap)&#123; //1、判断传入的参数是不是合法 Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); if (policyMap==null||policyMap.isEmpty())&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;传入什么东东&quot;); return resultMap; &#125; //2、从StockDao接口中调用insertLimitPolicy方法 boolean result = iStockDao.insertLimitPolicy(policyMap); //3、判断执行成功或失败，如果失败，返回错误信息 if (!result)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;数据执行咋又失败了&quot;); return resultMap; &#125; //4、如果成功，写入redis，需要写入有效期，key取名：LIMIT_POLICY_&#123;sku_id&#125; long diff = 0; String now = restTemplate.getForObject(&quot;http://leyou-time-server/getTime&quot;, String.class); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); //结束日期减去当前日期得到政策的有效期 try &#123; Date end_time = simpleDateFormat.parse(policyMap.get(&quot;end_time&quot;).toString()); Date now_time = simpleDateFormat.parse(now); diff = (end_time.getTime() - now_time.getTime())/1000; if (diff&lt;0)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;结束时间不能小于当前时间&quot;); return resultMap; &#125; &#125; catch (ParseException e) &#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;日期转换又失败了&quot;); return resultMap; &#125; String policy = JSON.toJSONString(policyMap); stringRedisTemplate.opsForValue().set(&quot;LIMIT_POLICY_&quot;+policyMap.get(&quot;sku_id&quot;).toString(), policy, diff, TimeUnit.SECONDS); ArrayList&lt;Map&lt;String, Object&gt;&gt; list = iStockDao.getStock(policyMap.get(&quot;sku_id&quot;).toString()); String sku = JSON.toJSONString(list.get(0)); stringRedisTemplate.opsForValue().set(&quot;SKU_&quot;+policyMap.get(&quot;sku_id&quot;).toString(), sku, diff, TimeUnit.SECONDS); //5、返回正常信息 resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap; &#125; 注意：这里的Service有业务逻辑判断，首先判断传入的json是否可以转化成功，其次是写入数据库成功或者失败。 这里加入了一个@Transactional，是需要开启事务，需要记住只要是insert\\delete\\update这三个语句都需要开启事务，一旦写入数据库失败，可以回滚，由于上面涉及到的方法都是查询，所以不用开启事务 在StockController里增加一个insertLimitPolicy方法，需要增加注解@RequestMapping，其中value = “/insertLimitPolicy/{jsonObj}，返回一个商品Map，代码如下： 1234@RequestMapping(value = &quot;/insertLimitPolicy/&#123;jsonObj&#125;&quot;)public Map&lt;String, Object&gt; insertLimitPolicy(@PathVariable(&quot;jsonObj&quot;) String jsonObj)&#123; return iStockService.insertLimitPolicy(jsonObj);&#125; 测试insertLimitPolicy方法，在浏览器中输入http://localhost:7000/insertLimitPolicy/{sku_id:’26816294479’,quanty:1000,price:1000,begin_time:’2019-08-05 11:00’,end_time:’2019-10-05 12:00’} 4.3.11. 在新增政策的时候存入redis步骤： 1、配置redis依赖 2、配置文件application.properties增加redis配置 3、编写启动类增加restTemplate，需要调用时间服务 4、在Service时增加 RestTemplate 和 StringRedisTemplate 的变量声明 4、写入政策数据库表。 5、将政策写入Redis，key为 LIMIT_POLICY_{sku_id}。 6、结束时间到了，利用Redis的删除机制，自动删除，以减少内存占用。时间通过政策结束时间减去当前时间得到。 代码如下： 声明StringRestTemplate 12@AutowiredStringRedisTemplate stringRedisTemplate; 修改StockService里的insertLimitPolicy方法，增加以下代码 4.3.12. 封装商品列表和商品详情时取redis政策的方法（getLimitPolicy）步骤： 1、循环商品列表 2、取出每个sku_id的政策 3、赋值给商品列表中 封装方法：getLimitPolicy 代码如下： 12345678910111213141516171819202122232425262728293031323334353637private Map&lt;String, Object&gt; getLimitPolicy(ArrayList&lt;Map&lt;String, Object&gt;&gt; list)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); for (Map&lt;String, Object&gt; skuMap: list)&#123; //3.1、从redis取出政策 String policy = stringRedisTemplate.opsForValue().get(&quot;LIMIT_POLICY_&quot;+skuMap.get(&quot;sku_id&quot;).toString()); //3.2、判断有政策的才继续 if (policy!=null&amp;&amp;!policy.equals(&quot;&quot;))&#123; Map&lt;String, Object&gt; policyInfo = JSONObject.parseObject(policy, Map.class); //3.3、开始时间小于等于当前时间，并且当前时间小于等于结束时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); String now = restTemplate.getForObject(&quot;http://leyou-time-server/getTime&quot;, String.class); try &#123; Date end_time = simpleDateFormat.parse(policyInfo.get(&quot;end_time&quot;).toString()); Date begin_time = simpleDateFormat.parse(policyInfo.get(&quot;begin_time&quot;).toString()); Date now_time = simpleDateFormat.parse(now); if (begin_time.getTime()&lt;=now_time.getTime()&amp;&amp;now_time.getTime()&lt;=end_time.getTime())&#123; skuMap.put(&quot;limitPrice&quot;, policyInfo.get(&quot;price&quot;)); skuMap.put(&quot;limitQuanty&quot;, policyInfo.get(&quot;quanty&quot;)); skuMap.put(&quot;limitBeginTime&quot;, policyInfo.get(&quot;begin_time&quot;)); skuMap.put(&quot;limitEndTime&quot;, policyInfo.get(&quot;end_time&quot;)); skuMap.put(&quot;nowTime&quot;, now); &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 这里要注意：将政策写入列表里传给前端页面 limitPrice：政策上的价格 limitBeginTime：政策上开始时间 limitEndTime：政策上结束时间 nowTime：当前时间 4.4. 创建库存服务（端口号6001） 注意：这里配置端口号不是6000，而是6001，原因是Chrome谷歌浏览器6000端口是访问不了的 4.4.1. 创建库存表结构1、库房表 12345678DROP TABLE IF EXISTS `tb_warehouse`;CREATE TABLE `tb_warehouse` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;库房id&#x27;, `name` VARCHAR(64) NOT NULL COMMENT &#x27;库房名称&#x27;, `create_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` TIMESTAMP NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 2、库存主表 用途：用于存储库存余量 12345678DROP TABLE IF EXISTS `tb_stock_storage`;CREATE TABLE `tb_stock_storage` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `warehouse_id` BIGINT(20) NOT NULL COMMENT &#x27;库房id&#x27;, `sku_id` BIGINT(20) NOT NULL COMMENT &#x27;skuid&#x27;, `quanty` DECIMAL(18,2) COMMENT &#x27;剩余数量&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 3、库存历史表 用途：用于存储库存出入库明细历史 12345678DROP TABLE IF EXISTS `tb_stock_storage_history`;CREATE TABLE `tb_stock_storage_history` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `stock_storage_id` BIGINT(20) NOT NULL COMMENT &#x27;库存主表id&#x27;, `in_quanty` DECIMAL(18,2) COMMENT &#x27;入库数量&#x27;, `out_quanty` DECIMAL(18,2) COMMENT &#x27;出库数量&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 库存写入规则： 注意：库存主表，一个库房一个商品只有一条记录，quanty存入的是剩余数量。 库存历史表，每一个库房的每一个商品对应一个库存主表ID，记录出入库的历史数量。 写入规则说明： 1、通过sku_id判断库存主表是否有数据； 2、如果有数据，得到库存主表的id； 3、如果没有数据，则先写入库存主表，得到库存主表的id； 4、根据库存主表的id写入到历史表； 5、当库存主表有数据时，通过库存主表的id再次更新数量。 4.4.2. 创建库存服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouStorage，Description为Storage For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 leyouStorage，Content root为路径+leyouStorage，选择Finish，此时在项目文件夹下会创建一个 leyouStorage文件夹 4.4.3. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包，利用alibaba的fastjson解析json数据，所以引入alibaba.fastjson用到的jar包，mysql-connector-java与spring-boot-starter-data-jpa依赖引入mysql连接使用的jar包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouStorage&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 4.4.4. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 12345678server.port=6001spring.application.name=leyou-storageeureka.client.service-url.defaultZone=http://localhost:9000/eureka/spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/code1_2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouStorageApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端 123456789@SpringBootApplication@EnableEurekaClientpublic class StorageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StorageApplication.class, args); &#125;&#125; 测试运行库存服务，在Eureka注册中心中可以看到 leyou-Storage服务，证明服务启动成功 4.4.5. 创建controller\\service\\dao文件夹，并创建StorageController.java\\StorageService.java\\StorageDao.java文件创建Dao层接口文件，IStorageDao 1public interface IStorageDao &#123;&#125; 给StorageDao.java类增加注解，@Repository用于标注数据访问组件，即DAO组件，实现IStroageDao接口 12@Repositorypublic class StorageDao implements IStorageDao&#123;&#125; 声明 JDBCTemplate 方法，用于连接数据库使用 12@Autowiredprivate JdbcTemplate jdbcTemplate; 创建Service层接口文件，IStorageService 给StorageService.java类增加注解，实现IStorageService的接口 12@Servicepublic class StorageService implements IStorageService &#123;&#125; 加入IStorageDao接口的引用 12@Autowiredprivate IStorageDao iStorageDao; 给StorageController.java类增加注解 123@RestController@Configurationpublic class StorageController &#123;&#125; 加入IStorageService接口的引用 12@Autowiredprivate IStorageService iStorageService; 4.4.6. 创建查询库存方法（getStockStorage）用途：查询实际库存是否扣减或增加 在StorageDao.java类中增加 getStockStorage方法，带一个sku_id参数，意思是通过sku_id进行查找，返回一个商品list，代码如下： 1234567public ArrayList&lt;Map&lt;String, Object&gt;&gt; getStockStorage(String sku_id)&#123; //1、SQL取值 String sql = &quot;SELECT sku_id, quanty FROM tb_stock_storage WHERE sku_id = ?&quot;; //2、返回数据 return (ArrayList&lt;Map&lt;String,Object&gt;&gt;) jdbcTemplate.queryForList(sql, sku_id);&#125; 在StorageService.java类中增加getStockStorage方法，返回一个商品Map，代码如下： 12345678910111213141516171819public Map&lt;String, Object&gt; getStockStorage(String sku_id)&#123; //1、先取得一个商品的库存 ArrayList&lt;Map&lt;String ,Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); list = iStorageDao.getStockStorage(sku_id); //2、判断如果stockDao取出的商品为空，返回一个提示 Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); if (list==null||list.isEmpty())&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;完了，服务器挂了，数据没取出来！&quot;); return resultMap; &#125; //3、判断如果取出的商品不为空，返回数据 resultMap.put(&quot;storage&quot;, list); resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 在StorageController.java类中增加getStockStorage方法，需要增加注解@RequestMapping，其中value = “/getStockStorage/{sku_id}，返回一个商品Map，代码如下： 1234@RequestMapping(value = &quot;/getStockStorage/&#123;sku_id&#125;&quot;)public Map&lt;String, Object&gt; getStockStorage(@PathVariable(&quot;sku_id&quot;) String sku_id)&#123; return iStorageService.getStockStorage(sku_id);&#125; 4.4.7. 创建增减库存方法（insertStorage）用途：监听队列时，获取消息，扣减库存 首先要了解库存的表结构：库存主表、库存历史表。库存主表保存的是库存商品现有的剩余数量，库存历史表是保存库存商品出入库的历史。 例如：A商品库存在a库房里还剩10个，则主表里是a库房，A商品，10个数量 进货20个，买出10个，则在历史表里有两条记录，一条是入20个，一条是出10个，汇总起来的数量正好等于库存主表的剩余数量 12有人会问了：那查库存数量直接汇总历史表不就可以了？答案是否，例如京东的销售一件商品会有10万+，那么历史表里有10万+数据，汇总就会很耗时，直接通过主表就可以很轻松的拿到库存剩余数量。 在StorageDao.java类中增加 insertStorage方法，带三个sku_id，inquanty，outquanty参数，意思是写入哪个库房的哪个商品多少个，返回map，注意：这里库房是虚拟一个id是1的库房，所以写入的时候直接把warehouse_id赋值为1。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public Map&lt;String, Object&gt; insertStorage(String sku_id, double in_quanty, double out_quanty)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、查询库存主表是否有库存 String sql = &quot;SELECT id FROM tb_stock_storage WHERE sku_id = ?&quot;; ArrayList&lt;Map&lt;String, Object&gt;&gt; list = (ArrayList&lt;Map&lt;String, Object&gt;&gt;) jdbcTemplate.queryForList(sql, sku_id); int new_id = 0; double thisQuanty = in_quanty - out_quanty; boolean result = false; //2、如果有库存，获取id，作用一写入历史表，作用二反回来更新 if (list!=null&amp;&amp;list.size()&gt;0)&#123; new_id = Integer.parseInt(list.get(0).get(&quot;id&quot;).toString()); &#125;else &#123; //3、如果没有库存，写入主表库存，并且得到id，作用写入历史表 sql = &quot;INSERT INTO tb_stock_storage (warehouse_id, sku_id, quanty) VALUES (1, &quot;+sku_id+&quot;, &quot;+thisQuanty+&quot;)&quot;; KeyHolder keyHolder = new GeneratedKeyHolder(); final String finalSql = sql; result = jdbcTemplate.update(new PreparedStatementCreator() &#123; public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123; PreparedStatement preparedStatement = connection.prepareStatement(finalSql, Statement.RETURN_GENERATED_KEYS); return preparedStatement; &#125; &#125;, keyHolder)==1; //3.1、如果写入失败，返回错误信息 msg if (!result)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;写入库存主表失败了！&quot;); return resultMap; &#125; new_id = keyHolder.getKey().intValue(); &#125; //4、写入历史表 sql = &quot;INSERT INTO tb_stock_storage_history (stock_storage_id, in_quanty, out_quanty) &quot; + &quot;VALUES (?, ?, ?)&quot;; result = jdbcTemplate.update(sql, new_id, in_quanty, out_quanty)==1; //4.1、如果写入失败，返回错误信息 msg if (!result)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;写入库存历史表失败了！&quot;); return resultMap; &#125; //5、如果有库存，反回来更新主表 if (list!=null&amp;&amp;list.size()&gt;0)&#123; sql = &quot;UPDATE tb_stock_storage SET quanty = quanty + ? &quot; + &quot;WHERE id = ? AND quanty + ? &gt;= 0&quot;; result = jdbcTemplate.update(sql, thisQuanty, new_id, thisQuanty)==1; //5.1、如果写入失败，返回错误信息 msg if (!result)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;更新库存主表失败了！&quot;); return resultMap; &#125; &#125; //6、返回正常数据 resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 首先检查这个商品是否有库存，就是主表是否有这个商品，如果有，证明以前这个商品有入库，所以对库存主表进行更新，如果没有，证明以前这个商品没有入库，所以要写入库存主表，原因是库存主表直接可以查询到库存余额，所以需要直接记录库存余额的数量。 库存历史表用于记录出入的历史，直接写入即可。 代码逻辑分析： 根据库房+商品SKU在库存主表中查询是否有库存 如果没有，写入库存主表，并得到写入主表的id，这个id用来写入历史表 如果有，直接根据第一次的查询获取主表的id 利用获取到的库存主表id写入库存历史表 统一更新库存主表的数量 在StorageService.java类中增加insertStorage方法，返回一个商品Map，代码如下： 1234567891011121314151617181920212223@Transactionalpublic Map&lt;String, Object&gt; insertStorage(String sku_id, double in_quanty, double out_quanty)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、传入的参数 if (sku_id.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;商品的sku不能为空！&quot;); return resultMap; &#125; if (in_quanty==0&amp;&amp;out_quanty==0)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;入库数量和出库数量不能同时为0！&quot;); return resultMap; &#125; //2、调StorageDao的方法 resultMap = iStorageDao.insertStorage(sku_id, in_quanty, out_quanty); //3、返回 return resultMap;&#125; 由于库存属于敏感数据，所以操作库存的时候一定要加以判断，在Service判断逻辑，Dao里判断数据库逻辑。 在StorageController.java类中增加insertStorage方法，需要增加注解@RequestMapping，其中value = “/insertStorage/{warehouse_id}/{sku_id}/{inquanty}/{outquanty}”，返回一个商品Map，代码如下： 12345@RequestMapping(value = &quot;/insertStorage/&#123;sku_id&#125;/&#123;inquanty&#125;/&#123;outquanty&#125;&quot;)public Map&lt;String, Object&gt; insertStorage(@PathVariable(&quot;sku_id&quot;) String sku_id, @PathVariable(&quot;inquanty&quot;) double inquanty, @PathVariable(&quot;outquanty&quot;) double outquanty)&#123; return iStorageService.insertStorage(sku_id, inquanty, outquanty);&#125; 4.4.8. 测试库存增减直接通过页面访问 getStorageQuanty 方法，查询现有数量，再用insertStorage 方法增减，最后通过 getStorageQuanty 方法再查询 查询库存的地址为：http://localhost:6001/getStockStorage/26816294479 先查询一下库存有990个 再通过insertStorage方法增减库存，这里展示减10个， 写入库存的地址为：http://localhost:6001/insertStorage/26816294479/0/10 最后查询一次库存有980个， 查询库存的地址为：http://localhost:6001/getStockStorage/26816294479 4.4.9. 处理库存队列监听方法（storage_queue）新增依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在src\\main\\java\\com\\itheima\\leyou\\文件夹下新建文件夹queue，在queue文件夹下新建java文件StorageQueue 在StorageQueue.java里写入队列监听方法，调用iStorageService.insertStorage来写入库存，代码如下： 123456789101112131415161718192021222324@Componentpublic class StorageQueue &#123; @Autowired private IStorageService iStorageService; @RabbitListener(queues = &quot;storage_queue&quot;) public void getStorageQueue(String msg)&#123; System.out.println(&quot;storage_queue接收消息：&quot;+msg); Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); try &#123; result = iStorageService.insertStorage(msg, 0, 1); if (!(Boolean) result.get(&quot;result&quot;))&#123; System.out.println(&quot;storage_queue消息处理失败：&quot;+result.get(&quot;msg&quot;)); &#125; &#125;catch (Exception e)&#123; System.out.println(&quot;storage_queue消息处理失败：&quot;+e.getMessage()); &#125; System.out.println(&quot;storage_queue消息处理完毕！&quot;+result); &#125;&#125; 4.5. 创建会员服务（端口号5000） 4.5.1. 创建会员表结构12345678910111213DROP TABLE IF EXISTS `tb_user`;CREATE TABLE `tb_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `username` VARCHAR(32) NOT NULL COMMENT &#x27;用户名&#x27;, `password` VARCHAR(60) NOT NULL COMMENT &#x27;密码，加密存储&#x27;, `phone` VARCHAR(11) DEFAULT NULL COMMENT &#x27;注册手机号&#x27;, `create_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` TIMESTAMP NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE, UNIQUE KEY `phone` (`phone`)) ENGINE=INNODB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT=&#x27;用户表&#x27;; 4.5.2. 创建会员服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouUser，Description为User For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 leyouUser，Content root为路径+leyouUser，选择Finish，此时在项目文件夹下会创建一个 leyouUser文件夹 4.5.3. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包，利用alibaba的fastjson解析json数据，所以引入alibaba.fastjson用到的jar包，mysql-connector-java与spring-boot-starter-data-jpa依赖引入mysql连接使用的jar包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouUser&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 4.5.4. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 123456789101112131415161718192021222324252627server.port=5000spring.application.name=leyou-usereureka.client.service-url.defaultZone=http://localhost:9000/eureka/spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/code1_2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root#redis数据库编号，存在0~15共16个数据库spring.redis.database=0#redis服务器IPspring.redis.host=127.0.0.1#redis端口号spring.redis.port=6379#redis密码spring.redis.password=leyou#redis请求超时时间，超过此值redis自动断开连接spring.redis.timeout=10000ms#jedis最大连接数，超过此值则提示获取不到连接异常spring.redis.jedis.pool.max-active=32#jedis最大等待时间，超过此值会提示连接超时异常spring.redis.jedis.pool.max-wait=10000ms#jedis最大等待连接数spring.redis.jedis.pool.max-idle=32#jedis最小等待连接数spring.redis.jedis.pool.min-idle=0 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouUserApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端 123456789@SpringBootApplication@EnableEurekaClientpublic class UserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserApplication.class, args); &#125;&#125; 测试运行订单服务，在Eureka注册中心中可以看到 leyou-User服务，证明服务启动成功 4.5.5. 创建controller\\service\\dao文件夹，并创建UserController.java\\UserService.java\\UserDao.java文件创建Dao层接口文件，IUserDao 1public interface IUserDao &#123;&#125; 给UserDao.java类增加注解，@Repository用于标注数据访问组件，即DAO组件，实现IUserDao的接口 123@Repositorypublic class UserDao implements IUserDao &#123;&#125; 声明 JDBCTemplate 方法，用于连接数据库使用 12@Autowiredprivate JdbcTemplate jdbcTemplate; 创建Service层接口，IUserService 给UserService.java类增加注解，实现IUserService接口 12@Servicepublic class UserService implements IUserService&#123;&#125; 加入UserDao的引用 123@Autowiredprivate IUserDao iUserDao; 给UserController.java类增加注解 123@RestControllerpublic class UserController &#123;&#125; 加入UserService接口的引用 123@Autowiredprivate IUserService iUserService; 4.5.6. 创建查询会员方法（getUser）用途：给前端提供会员信息数据，主要用于前端会员登录 在UserDao.java类中增加 getUser方法，带两个username，password参数，意思是通过username和password进行查找，返回一个会员List，代码如下： 1234public ArrayList&lt;Map&lt;String, Object&gt;&gt; getUser(String username, String password)&#123; String sql = &quot;select id AS user_id, username, phone, password from tb_user where username = ?&quot;; return (ArrayList&lt;Map&lt;String,Object&gt;&gt;) jdbcTemplate.queryForList(sql, username);&#125; 在UserService.java类中增加getUser方法，返回一个商品List，代码如下： 12345678910111213141516171819202122public Map&lt;String, Object&gt; getUser(String username, String password)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、判断传入的参数是否有误 if (username==null||username.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;用户名不能为空！&quot;); return resultMap; &#125; //2、取会员列表 ArrayList&lt;Map&lt;String, Object&gt;&gt; list = iUserDao.getUser(username, password); if (list==null||list.isEmpty())&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;没找到会员信息！&quot;); return resultMap; &#125; resultMap = list.get(0); resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 4.5.7. 创建增加会员方法（insertUser）用途：给前端提供会员信息增加，主要用于前端会员注册 在UserDao.java类中增加 insertUser方法，带username，phone，password三个参数，返回一个Map，代码如下： 123456789101112public int insertUser(String username, String password)&#123; final String sql = &quot;insert into tb_user (username, phone, password) values (&#x27;&quot;+username+&quot;&#x27;, &#x27;&quot;+username+&quot;&#x27;, &#x27;&quot;+password+&quot;&#x27;)&quot;; KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() &#123; public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123; PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); return preparedStatement; &#125; &#125;, keyHolder); return keyHolder.getKey().intValue();&#125; 代码分析： 根据手机号先查询是否存在该用户 如果存在则提示该用户已经存在 根据三个参数写入会员表中 写入正确则返回result为true，写入错误则返回result为false 在UserService.java类中增加insertUser方法，返回一个商品Map，代码如下： 1234567891011121314151617181920212223242526@Transactionalpublic Map&lt;String, Object&gt; insertUser(String username, String password)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、判断传入的参数是否有误 if (username==null||username.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;用户名不能为空！&quot;); return resultMap; &#125; int user_id = iUserDao.insertUser(username, password); if (user_id&lt;=0)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;数据库没有执行成功！&quot;); return resultMap; &#125; resultMap.put(&quot;user_id&quot;, user_id); resultMap.put(&quot;username&quot;, username); resultMap.put(&quot;phone&quot;, username); resultMap.put(&quot;password&quot;, password); resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 注意：这里的Service有业务逻辑判断，如果Json转化错误或传入参数为空时，会导致数据库写入报错，因此在传入Dao层之前进行判断，传入的参数是否合法。解析出来的json也需要判断，用户名和电话不能为空 4.5.8. 在UserController.java类中增加login方法需要增加注解@RequestMapping，其中value = “/login，返回一个Map，代码如下： 123456789101112131415161718192021@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)public Map&lt;String, Object&gt; login(String username, String password, HttpServletRequest httpServletRequest)&#123; //1、取会员 Map&lt;String, Object&gt; userMap = new HashMap&lt;String, Object&gt;(); userMap = iUserService.getUser(username, password); //2、没取到会员，写入会员 if (!(Boolean) userMap.get(&quot;result&quot;))&#123; userMap = iUserService.insertUser(username, password); &#125; //3、写入session HttpSession httpSession = httpServletRequest.getSession(); String user = JSON.toJSONString(userMap); httpSession.setAttribute(&quot;user&quot;, user); Object o = httpSession.getAttribute(&quot;user&quot;); //4、返回信息 return userMap;&#125; 代码分析： login既用到了会员查询方法（getUser），又用到了会员增加方法（insertUser） 先根据前端页面传入的电话和密码查找会员，如果找到了，直接登录，如果没找到，直接注册一个，一般的实际项目中，这里会有两个验证的环节，一个是验证码，主要用于验证手机号；一个是图片验证，主要防止短信轰炸。 将会员信息写入session 4.6. 创建订单服务（端口号4000） 4.6.1. 创建订单表结构1、订单主表 用途：用于存储订单主表信息，例如：整单金额、会员、支付类型、付款时间等。 2、订单明细表 用途：用于存订单明细，和订单主表进行关联，一张订单可能会有多个明细，例如：一个会员买了多件商品，每一条明细的数量、单价、金额等。 3、订单物流状态表 用途：用于存储订单的物流状态，和订单主表进行关联，一张订单会有多个明细状态，例如：每个商品的物流公司、物流状态、是否签收等。 4.6.2. 创建订单服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouOrder，Description为Order For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 leyouOrder，Content root为路径+leyouOrder，选择Finish，此时在项目文件夹下会创建一个 leyouOrder文件夹 4.6.3. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包，利用alibaba的fastjson解析json数据，所以引入alibaba.fastjson用到的jar包，mysql-connector-java与spring-boot-starter-data-jpa依赖引入mysql连接使用的jar包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouOrder&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 4.6.4. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 12345678910111213141516171819202122232425262728server.port=4000spring.application.name=leyou-ordereureka.client.service-url.defaultZone=http://localhost:9000/eureka/spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/code1_2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=root#redis数据库编号，存在0~15共16个数据库spring.redis.database=0#redis服务器IPspring.redis.host=127.0.0.1#redis端口号spring.redis.port=6379#redis密码spring.redis.password=leyou#redis请求超时时间，超过此值redis自动断开连接spring.redis.timeout=10000ms#jedis最大连接数，超过此值则提示获取不到连接异常spring.redis.jedis.pool.max-active=32#jedis最大等待时间，超过此值会提示连接超时异常spring.redis.jedis.pool.max-wait=10000ms#jedis最大等待连接数spring.redis.jedis.pool.max-idle=32#jedis最小等待连接数spring.redis.jedis.pool.min-idle=0 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouOrderApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端 123456789@SpringBootApplication@EnableEurekaClientpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 测试运行订单服务，在Eureka注册中心中可以看到 leyou-Order服务，证明服务启动成功 4.6.5. 创建controller\\service\\dao文件夹，并创建OrderController.java\\OrderService.java\\OrderDao.java文件创建Dao层接口文件，IOrderDao 1public interface IOrderDao&#123;&#125; 给OrderDao.java类增加注解，@Repository用于标注数据访问组件，即DAO组件，实现IOrderDao接口 12@Repositorypublic class OrderDao implements IOrderDao &#123;&#125; 声明 JDBCTemplate 方法，用于连接数据库使用 12@AutowiredJdbcTemplate jdbcTemplate; 创建Service层接口文件，IOrderService 给OrderService.java类增加注解，实现IOrderService接口 12@Servicepublic class OrderService implements IOrderService &#123;&#125; 加入IOrderDao的引用 12@Autowiredprivate IOrderDao iOrderDao; 给OrderController.java类增加注解 12@RestControllerpublic class OrderController &#123;&#125; 加入IOrderService的引用 12@Autowiredprivate IOrderService iOrderService; 4.6.6. 增加创建订单方法（createOrder）主要用于前端提交订单页面调用，并写入订单队列， 注意：这里需要返回 order_id，支付页面通过 order_id进行查询。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public Map&lt;String, Object&gt; createOrder(String sku_id, String user_id)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); //1、判断sku_id if (sku_id==null||sku_id.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;前端又传错了！&quot;); return resultMap; &#125; //2、取redis政策 String order_id = String.valueOf(System.currentTimeMillis()); String policy = stringRedisTemplate.opsForValue().get(&quot;LIMIT_POLICY_&quot;+sku_id); if (policy!=null&amp;&amp;!policy.equals(&quot;&quot;))&#123; //3、开始时间小于等于当前时间，当前时间小于等于结束 Map&lt;String, Object&gt; policyMap = JSONObject.parseObject(policy, Map.class); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;); String now = restTemplate.getForObject(&quot;http://leyou-time-server/getTime&quot;, String.class); try &#123; Date begin_time = simpleDateFormat.parse(policyMap.get(&quot;begin_time&quot;).toString()); Date end_time = simpleDateFormat.parse(policyMap.get(&quot;end_time&quot;).toString()); Date now_time = simpleDateFormat.parse(now); if (begin_time.getTime()&lt;=now_time.getTime()&amp;&amp;now_time.getTime()&lt;=end_time.getTime())&#123; int limitQuanty = Integer.parseInt(policyMap.get(&quot;quanty&quot;).toString()); //4、redis计数器 // +1+1+1=3 4 if (stringRedisTemplate.opsForValue().increment(&quot;SKU_QUANTY_&quot;+sku_id, 1)&lt;=limitQuanty)&#123; //5、写入队列 // tb_order: order_id, total_fee, actual_fee, post_fee, payment_type, user_id, status, create_time // tb_order_detail: order_id, sku_id, num, title, own_spec, price, image, create_time // tb_sku: sku_id, title, images, stock, price, indexes, own_spec String sku = stringRedisTemplate.opsForValue().get(&quot;SKU_&quot;+sku_id); Map&lt;String, Object&gt; skuMap = JSONObject.parseObject(sku, Map.class); Map&lt;String, Object&gt; orderInfo = new HashMap&lt;String, Object&gt;(); orderInfo.put(&quot;order_id&quot;, order_id); orderInfo.put(&quot;total_fee&quot;, skuMap.get(&quot;price&quot;)); orderInfo.put(&quot;actual_fee&quot;, policyMap.get(&quot;price&quot;)); orderInfo.put(&quot;post_fee&quot;, 0); orderInfo.put(&quot;payment_type&quot;, 0); orderInfo.put(&quot;user_id&quot;, user_id); orderInfo.put(&quot;status&quot;, 1); orderInfo.put(&quot;create_time&quot;, now); orderInfo.put(&quot;sku_id&quot;, skuMap.get(&quot;sku_id&quot;)); orderInfo.put(&quot;num&quot;, 1); orderInfo.put(&quot;title&quot;, skuMap.get(&quot;title&quot;)); orderInfo.put(&quot;own_spec&quot;, skuMap.get(&quot;own_spec&quot;)); orderInfo.put(&quot;price&quot;, policyMap.get(&quot;price&quot;)); orderInfo.put(&quot;image&quot;, skuMap.get(&quot;images&quot;)); String order = JSON.toJSONString(orderInfo); try &#123; amqpTemplate.convertAndSend(&quot;order_queue&quot;, order); &#125;catch (Exception e)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;写入队列异常！&quot;); return resultMap; &#125; &#125;else &#123; //如果超出了计数器，返回商品已经售完了 resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;3亿9被踢回去了！&quot;); return resultMap; &#125; &#125;else &#123; //如果结束时间大于当前时间，返回活动已经过期 resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;活动已经过期！&quot;); return resultMap; &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;else &#123; //政策没有取出数，返回活动已经过期 resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;活动已经过期！&quot;); return resultMap; &#125; //6、返回正常数据，带着订单号 resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); resultMap.put(&quot;order_id&quot;, order_id); return resultMap;&#125; 在OrderController.java里增加创建订单的方法，代码如下： 1234567891011121314@RequestMapping(value = &quot;/createOrder/&#123;sku_id&#125;&quot;)public Map&lt;String, Object&gt; createOrder(@PathVariable(&quot;sku_id&quot;) String sku_id, HttpServletRequest httpServletRequest)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); HttpSession httpSession = httpServletRequest.getSession(); Object userObj = httpSession.getAttribute(&quot;user&quot;); if (userObj==null)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;会员没有登录不能购买！&quot;); return resultMap; &#125; Map&lt;String, Object&gt; userMap = JSONObject.parseObject(userObj.toString(), Map.class); return iOrderService.createOrder(sku_id, userMap.get(&quot;user_id&quot;).toString());&#125; 注意：需要从session里取值，如果没有取到会员信息则不能购买！ 4.6.7. 创建写入订单方法（insertOrder）主要应用于队列写入订单，在OrderDao.java中增加insertOrder方法，代码如下： 123456789101112131415161718public boolean insertOrder(Map&lt;String, Object&gt; orderInfo)&#123; //写入主表 String sql = &quot;insert into tb_order (order_id, total_fee, actual_fee, post_fee, payment_type, user_id, status, create_time) &quot; + &quot;values (?, ?, ?, ?, ?, ?, ?, ?)&quot;; boolean result = jdbcTemplate.update(sql, orderInfo.get(&quot;order_id&quot;), orderInfo.get(&quot;total_fee&quot;), orderInfo.get(&quot;actual_fee&quot;), orderInfo.get(&quot;post_fee&quot;), orderInfo.get(&quot;payment_type&quot;), orderInfo.get(&quot;user_id&quot;), orderInfo.get(&quot;status&quot;), orderInfo.get(&quot;create_time&quot;))==1; //写入明细表 if (result)&#123; sql = &quot;INSERT INTO tb_order_detail (order_id, sku_id, num, title, own_spec, price, image, create_time) &quot; + &quot;VALUES (?, ?, ?, ?, ?, ?, ?, ?)&quot;; result = jdbcTemplate.update(sql, orderInfo.get(&quot;order_id&quot;), orderInfo.get(&quot;sku_id&quot;), orderInfo.get(&quot;num&quot;), orderInfo.get(&quot;title&quot;), orderInfo.get(&quot;own_spec&quot;), orderInfo.get(&quot;price&quot;), orderInfo.get(&quot;image&quot;), orderInfo.get(&quot;create_time&quot;))==1; &#125; return result;&#125; 在OrderService.java里增加insertOrder方法 1234567891011121314151617181920public Map&lt;String, Object&gt; insertOrder(Map&lt;String, Object&gt; orderInfo)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); if (orderInfo==null||orderInfo.isEmpty())&#123; map.put(&quot;result&quot;, false); map.put(&quot;msg&quot;, &quot;传入参数有误！&quot;); return map; &#125; boolean result = iOrderDao.insertOrder(orderInfo); if (!result)&#123; map.put(&quot;result&quot;, false); map.put(&quot;msg&quot;, &quot;订单写入失败！&quot;); return map; &#125; map.put(&quot;result&quot;, true); map.put(&quot;msg&quot;, &quot;&quot;); return map;&#125; 由队列调用iOrderService.insertOrder 4.6.8. 创建订单队列（order_queue）需要的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在src\\main\\java\\com\\itheima\\leyou\\文件夹下新建文件夹queue，在queue文件夹下新建java文件OrderQueue 12345678910111213141516171819202122232425@Componentpublic class OrderQueue &#123; @Autowired private IOrderService iOrderService; @RabbitListener(queues = &quot;order_queue&quot;) public void insertOrder(String msg)&#123; //1、接收消息并输出 System.out.println(&quot;order_queue接收消息：&quot;+msg); //2、调用一个写入订单方法 Map&lt;String, Object&gt; orderInfo = JSONObject.parseObject(msg, Map.class); Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); resultMap = iOrderService.insertOrder(orderInfo); //3、如果没写成功输出错误消息 if (!(Boolean) resultMap.get(&quot;result&quot;))&#123; System.out.println(&quot;order_queue处理消息失败：&quot;); &#125; //4、成功输出消息 System.out.println(&quot;order_queue处理消息成功！&quot;); &#125;&#125; 4.6.9. 测试创建订单先将session的判断挂起，user_id赋值为1。 在浏览器里输入 http://localhost:4000/createOrder/26816294479 队列也处理成功。 4.6.10. 创建查询订单方法（getOrder）用途：查询订单详情，用于会员中心–我的订单查询 首先了解订单的表结构为：订单主表、订单明细表、订单物流状态表，一张订单有一个主表，多个明细，多个物流状态。 在OrderDao.java类中增加 getOrder方法，带一个orderid参数，意思是通过orderid进行查找，返回一个订单map，代码如下： 123456public ArrayList&lt;Map&lt;String, Object&gt;&gt; getOrder(String order_id)&#123; String sql = &quot;select d.sku_id, m.order_id, d.price &quot; + &quot;from tb_order m inner join tb_order_detail d on m.order_id = d.order_id &quot; + &quot;where m.order_id = ?&quot;; return (ArrayList&lt;Map&lt;String, Object&gt;&gt;) jdbcTemplate.queryForList(sql, order_id);&#125; 在StorageService.java类中增加getOrder方法，返回一个商品Map，代码如下： 123456789101112131415public Map&lt;String, Object&gt; getOrder(String order_id)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); if (order_id==null||order_id.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;参数传入有误！&quot;); return resultMap; &#125; ArrayList&lt;Map&lt;String, Object&gt;&gt; list = iOrderDao.getOrder(order_id); resultMap.put(&quot;order&quot;, list); resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 在StorageController.java类中增加getOrder方法，需要增加注解@RequestMapping，其中value = “/getOrder/{orderid}，返回一个商品Map，代码如下： 1234@RequestMapping(value = &quot;/getOrder/&#123;order_id&#125;&quot;)public Map&lt;String, Object&gt; getOrder(@PathVariable(&quot;order_id&quot;) String order_id)&#123; return iOrderService.getOrder(order_id);&#125; 4.6.11. 创建更新订单状态方法（updateOrderStatus）主要应用于队列更新订单状态的方法，在OrderDao.java中增加updateOrderStatus方法，代码如下： 1234public boolean updateOrderStatus(String order_id)&#123; String sql = &quot;update tb_order set status = 2 where order_id = ?&quot;; return jdbcTemplate.update(sql, order_id)==1;&#125; 4.6.12. 创建订单支付方法（payOrder）主要用于前端支付页面调用，并写入订单状态更新队列 在OrderService.java中增加payOrder方法 12345678910111213141516171819202122public Map&lt;String, Object&gt; payOrder(String order_id, String sku_id)&#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); if (order_id==null||order_id.equals(&quot;&quot;))&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;订单有误！&quot;); return resultMap; &#125; boolean result = iOrderDao.updateOrderStatus(order_id); if (!result)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;订单状态更新失败！&quot;); return resultMap; &#125; amqpTemplate.convertAndSend(&quot;storage_queue&quot;, sku_id); resultMap.put(&quot;result&quot;, true); resultMap.put(&quot;msg&quot;, &quot;&quot;); return resultMap;&#125; 在OrderController.java中增加payOrder方法 12345678910111213@RequestMapping(value = &quot;/payOrder/&#123;order_id&#125;/&#123;sku_id&#125;&quot;)public Map&lt;String, Object&gt; payOrder(@PathVariable(&quot;order_id&quot;) String order_id, @PathVariable(&quot;sku_id&quot;) String sku_id)&#123; //正常情况下在这里会调用支付接口，我们这里模拟支付已经返回正常数据 boolean isPay = true; Map&lt;String, Object&gt; resultMap = new HashMap&lt;String, Object&gt;(); if (!isPay)&#123; resultMap.put(&quot;result&quot;, false); resultMap.put(&quot;msg&quot;, &quot;支付接口调用失败！&quot;); return resultMap; &#125; return iOrderService.payOrder(order_id, sku_id);&#125; 4.6.13. 测试查询订单直接通过页面访问 getOrder 方法查询，http://localhost:4000/getOrder/1565019341112 4.7. 创建网关服务（端口号80） 4.7.1. 创建网关服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为ZuulServer，Description为Zuul For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 ZuulServer，Content root为路径+ZuulServer，选择Finish，此时在项目文件夹下会创建一个 ZuulServer文件夹 4.7.2. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouZuul&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 4.7.3. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 12345678910111213141516171819202122232425262728293031323334353637383940server.port=80spring.application.name=leyou-zuuleureka.client.service-url.defaultZone=http://localhost:9000/eureka/#忽略框架默认的服务映射路径zuul.ignored-services=&#x27;*&#x27;#不忽略框架与权限相关的头信息zuul.ignore-security-headers=falsezuul.host.socket-timeout-millis=60000zuul.host.connect-timeout-millis=60000zuul.host.max-total-connections=500zuul.routes.leyou-client.path=/leyouClient/**zuul.routes.leyou-client.serviceId=leyou-client#防止session不一致问题zuul.routes.leyou-client.sensitiveHeaders=&quot;*&quot;zuul.routes.leyou-order.path=/leyouOrder/**zuul.routes.leyou-order.serviceId=leyou-orderzuul.routes.leyou-order.sensitiveHeaders=&quot;*&quot;zuul.routes.leyou-user.path=/leyouUser/**zuul.routes.leyou-user.serviceId=leyou-userzuul.routes.leyou-user.sensitiveHeaders=&quot;*&quot;zuul.routes.leyou-stock.path=/leyouStock/**zuul.routes.leyou-stock.serviceId=leyou-stockzuul.routes.leyou-stock.sensitiveHeaders=&quot;*&quot;zuul.routes.leyou-storage.path=/leyouStorage/**zuul.routes.leyou-storage.serviceId=leyou-storagezuul.routes.leyou-storage.sensitiveHeaders=&quot;*&quot;zuul.routes.leyou-time-server.path=/leyouTimeServer/**zuul.routes.leyou-time-server.serviceId=leyou-time-serverzuul.routes.leyou-time-server.sensitiveHeaders=&quot;*&quot; zuul.routes.leyou-order.path为每个服务的路径 zuul.routes.leyou-stock.serviceId为每个服务的编号 以此类推，将所有服务进行配置 注意：zuul使用80端口，在访问的时候可以不用输入端口号。 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouTimeServerApplication，在已经生成的启动类中加入 @EnableZuulProxy，当Zuul与Eureka、Ribbon等组件配合使用时，我们使用@EnableZuulProxy 123456789@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; 测试运行网关服务，利用前面的查询库存的方法：getStockStorage 将原来的 http://localhost:6001/getStockStorage/26816294479 改为http://localhost/leyouStorage/getStockStorage/26816294479 4.8. 创建页面服务（端口号3000） 4.8.1. 创建页面服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouClient，Description为Client For leyou Project，选择Next 第三步：选择 Web，选择 Spring Web Starter，选择Next 第四步：Module name 为 leyouClient，Content root为路径+leyouClient，选择Finish，此时在项目文件夹下会创建一个 leyouClient文件夹 4.8.2. 配置pom.xml在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouClient&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 在pom.xml中的build标签中必须加入以下资源包，否则访问页面会报404，原因是SpringBoot必须先指定路径，然后编译成功再启动，才可以访问页面 1234567891011121314151617181920212223242526272829303132333435&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 必须引入以下资源包才可以解决 jsp404 的问题 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;!-- 指定resources插件处理哪个目录下的资源文件 --&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;!--注意此次必须要放在此目录下才能被访问到 --&gt; &lt;targetPath&gt;resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 解决 jsp404 --&gt;&lt;/build&gt; 4.8.3. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 123server.port=3000spring.application.name=leyou-clienteureka.client.service-url.defaultZone=http://localhost:9000/eureka/ 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouClientApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端 123456789@SpringBootApplication@EnableEurekaClientpublic class ClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ClientApplication.class, args); &#125;&#125; 测试运行页面服务，在Eureka注册中心中可以看到 leyou-client服务，证明服务启动成功 4.8.4. 创建页面文件夹1、 在main下创建webapp文件夹 2、在webapp文件夹下创建page文件夹，用来存放html页面文件 3、在webapp文件夹下创建resources文件夹，用来存入引入的插件，这里用到的是bootstrap和jquery，bootstrap主要是页面的样式，jquery主要是使用ajax与后台交互。 4.8.5. 引入bootstrap将bootstrap-4.3.1-dist文件夹复制到resources文件夹下 将jquery文件夹复制到resources文件夹下 4.8.6. 创建会员登录页面（loginPage.html）用途：用于会员注册、会员登录 将loginPage.html复制到 main\\webapp\\page\\文件夹下 4.8.7. 创建商品列表页面（stockListPage.html）用途：用于展示商品列表 将stockListPage.html复制到 main\\webapp\\page\\文件夹下 4.8.8. 创建商品详情页面（stockDetailPage.html）用途：用于展示商品详情 将stockDetailPage.html复制到 main\\webapp\\page\\文件夹下 4.8.9. 创建订单页面（createOrderPage.html）用途：用于提交订单 将createOrderPage.html复制到 main\\webapp\\page\\文件夹下 4.8.8. 创建支付页面（payPage.html）用途：用于支付订单 将payPage.html复制到 main\\webapp\\page\\文件夹下 4.8.8. 创建秒杀政策页面（limitPolicyPage.html）用途：用于秒杀政策添加 将limitPolicyPage.html复制到 main\\webapp\\page\\文件夹下 4.9. 创建配置服务（端口号2000） 4.9.1 创建配置服务第一步：选择File-New-Module…，弹出的窗口中选择Spring initializr，选择Module SDK，选择Next 第二步：Group为com.itheima，Artifact为leyou，Name为leyouClient，Description为Client For leyou Project，选择Next 第三步：选择 Spring Cloud Discovery，选择 Eureka Discovery Client，选择Next 第四步：Module name 为 leyouConfig，Content root为路径+leyouConfig，选择Finish，此时在项目文件夹下会创建一个 leyouConfig文件夹 4.9.2. ConfigServer配置在生成的项目中，打开pom.xml，配置依赖，其中spring-cloud-starter-netflix-eureka-client为项目引入了Eureka客户端的jar包，spring-boot-starter-web引入了web场景下，web模块开发所用到的jar包，spring-cloud-config-server引入了配置服务器所用到的jar包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;leyouConfig&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 在src\\man\\resources文件夹下新增shared文件夹，用于存放各个服务的配置文件 4.9.3. 配置文件application.properties在生成的项目中，打开src\\man\\resources\\application.properties，配置端口号等 123456server.port=2000spring.application.name=leyou-config-servereureka.client.service-url.defaultZone=http://localhost:9000/eureka/spring.cloud.config.server.native.search-locations=classPath:/sharedspring.cloud.config.profile=devspring.profiles.active=native 在src\\man\\resources下新建一个shared文件夹 注意：在application.properties中spring.cloud.config.server.native.search-locations这一项指的是查找本地文件路径，指向shared中，实际项目中大部分软件公司这一项可能在某台服务器上或者远程仓库。 share文件夹里文件的命名规则为：各个服务配置文件中spring.application.name+配置服务的application.properties文件中的spring.cloud.config.profile值的内容。 例如：leyou-time-server是时间服务（leyouTimeServer）的spring.application.name，配置服务的application.properties文件中的spring.cloud.config.profile为dev，所以对于商品服务的配置文件名字是 leyou-time-server-dev.properties leyou-time-server-dev.properties配置内容： 1234server.port=8000spring.application.name=leyou-time-servereureka.client.service-url.defaultZone=http://localhost:9000/eureka/ 在生成的项目中，打开src\\main\\java\\com.itheima.leyou\\leyouConfigApplication，在已经生成的启动类中加入 @EnableEurekaClient，意思为启动Eureka客户端，并加入@EnableConfigServer，意思为启动Config配置服务 12345678910@SpringBootApplication@EnableEurekaClient@EnableConfigServerpublic class ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigApplication.class, args); &#125;&#125; 以商品服务为例： 时间服务增加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt; 将原商品服务配置文件main/resources/application.properties里的内容挂起，新建一个bootstrap.properties文件，代码如下： 12345spring.application.name=leyou-time-serverspring.cloud.config.profile=devspring.cloud.config.uri=http://localhost:2000spring.cloud.config.label=masterspring.profiles.active=dev 测试运行配置服务和商品服务，在Eureka注册中心中可以看到 leyou-config-server以及leyou-stock服务，证明服务配置成功 4.9.4. 优先找配置文件原则修改时间服务（leyouTimeServer）的application.properties配置文件 123server.port=8001spring.application.name=leyou-time-servereureka.client.service-url.defaultZone=http://localhost:9000/eureka/ 注意：这里端口号改成8001 启动配置服务，再启动时间服务，控制台可以看到启动的是8000 不启动配置服务，再启动时间服务，控制台可以看到启动的是8001 结论：服务启动时，优先找bootstrap.properties，如果找不到，再找application.properties，证明bootstrap比application的优先级要高。 五、项目测试5.1. 新建秒杀政策地址：http://localhost/leyouClient/page/limitPolicyPage.html 选择商品，输入秒杀价格、秒杀库存、开始时间、结束时间，点保存。 5.2. 登录页面地址：http://localhost/leyouClient/page/loginPage.html 5.3. 商品列表页在登录页中输入手机号，密码，跳转商品列表页 地址：http://localhost/leyouClient/page/stockListPage.html 5.4. 商品详情页在商品列表页中选择一个商品 地址：http://localhost/leyouClient/page/stockDetailPage.html?sku_id=27359021557 5.5. 提交订单在商品详情页中点击【立即抢购】 地址：http://localhost/leyouClient/page/createOrderPage.html?sku_id=27359021557 5.6. 付款页面在提交订单页面点击【提交订单】 地址：http://localhost/leyouClient/page/payPage.html?order_id=1565061554849 点击【微信支付】，提示“支付成功” 关于队列 六、关于面试6.1. 以前做过什么项目？答：商城项目、商城秒杀系统，整个商城项目中秒杀是其中最关键的一个营销活动，所以独立出来成为一个系统。秒杀系统就是我主做的。 6.2. 项目上线了吗？外网能否访问？答：已经上线了，但是我们是外包公司，项目开发完之后布署到哪里不太清楚，所以不知道如何访问。 6.3. 项目收益是多少？答：由于是开发人员，收益这一块都是产品那边在管，所以对于开发人员来说这个不太清楚 6.4. 项目团队中有多少人？怎样分工？答：团队中有10个人，1个设计师，6个java开发，1个前端，2个测试。我在6人的开发团队中负责整体架构及部分代码，一般都是设计师写好概要设计，其中包含需求调研说明，项目背景，操作流程，使用技术架构，架构图。我们开发再完善详细设计，其中包含表结构，每个微服务能处理的业务，甚至还会写一些伪代码。前端负责页面开发，我们开发出来的版本交给测试人员进行测试，最终交付。 6.5. 项目中遇到了什么样的问题？是怎么解决的？答： 1、技术架构方面：刚开始的时候本来使用的是数据库来控制超买超卖，但是效率上有很大的问题，因为我们在压力测试的时候，数据库会造成很多死锁，前端页面就会没有响应。后来我们采用了redis缓存技术来解决超买超卖的问题，将秒杀的商品及库存全部存到redis里，然后秒杀一个减一个，都在缓存里处理，这样就有效的解决了效率问题。 2、开发方面：我在开发库存那一块代码的时候，库存总是减不成功，于是我先查看控制台日志，看是否有报错，然后分析，最后打断点，一行一行跟踪代码找到问题。 3、与前端的交互方面：我们提供的接口，前端那边接收到的数据解析不出来，这就需要我们输出一下我们提供接口返回的数据，看是否是有乱码，或者格式不对，字段不对等问题，也需要和前端一起联调。 4、测试方面：测试人员在提供测试报告之后，有一些问题很难重现，首先需要用他们的数据进行模拟，看是否是数据问题，其次是用他们的环境进行跟踪代码，看能否找到问题。 6.6. 分布式事务是如何处理的？答：分布式事务是通过 TCC 模式进行处理，比如订单和库存服务，订单服务和库存服务在开启事务之后先是执行 try 的逻辑，大家都没问题了，订单服务执行业务代码，然后执行confirm的逻辑，库存也执行业务代码，然后执行comfirm的逻辑，大家一起提交。如果库存服务 try 的逻辑执行失败时，会通知订单服务执行 cancel 的逻辑。 在大家都没问题的情况下，try要进行一次交互，然后 confirm 再进行一次交互，所以协调完两个服务会有成本。量小的时候没问题，但是量一旦很大的时候，这样就会造成排队现象。 所以我们没有使用分布式事务处理多个微服务之间的事务问题，我们先是通过redis来处理前端的请求，然后把业务进行拆分，拆分的业务使用消息队列中间件来解决，每个服务都开启自己的事务处理业务，这样可以更加高效的解决并发。 6.7. 项目开发用了多久？答：前期的调研加概要设计大概用了10天，我们补充详细设计大概是5天，开发用时在20天左右的时间，加上测试，联调，解决bug，复测，上线应该在1个半月左右。 6.8. 项目中用到了哪些技术？答：用的是SpringCloud微服务架构，主要解决后台服务压力过大的问题，所以根据不同模块进行拆分，每个开发小组负责一个微服务，缓存用的redis中间件，处理业务拆分用到的是RabbitMQ。 6.9. 项目中的数据都是通过SQL查询的吗？答：不完全是，比如商品取到的秒杀政策就是在redis里取的，不是通过SQL查询，而商品列表和商品详情都是通过SQL查询的。还有控制秒杀的数量都是在redis里进行控制的，而不是实时用SQL查询库存。 6.10. 项目中你觉得哪个模块最难？答：处理业务模块上我觉得库存模块最难，由于库存是敏感数据，操作都要非常谨慎，一旦库存出错，会给商家带来具大的损失。 如何处理大并发量是这个项目的难点，我们是通过redis控制超买超卖，通过消息队列RabbitMQ来对业务进行拆分。","categories":[],"tags":[]},{"title":"photo","slug":"photo","date":"2021-01-06T04:16:45.000Z","updated":"2021-01-06T04:18:27.080Z","comments":true,"path":"2021/01/06/photo/","link":"","permalink":"https://bingyuchan.github.io/2021/01/06/photo/","excerpt":"","text":"photo","categories":[],"tags":[]},{"title":"Mac和Linux远程连接服务器异常修复","slug":"Mac和Linux远程连接服务器异常修复","date":"2021-01-06T02:57:46.000Z","updated":"2021-01-06T04:31:10.802Z","comments":true,"path":"2021/01/06/Mac和Linux远程连接服务器异常修复/","link":"","permalink":"https://bingyuchan.github.io/2021/01/06/Mac%E5%92%8CLinux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%82%E5%B8%B8%E4%BF%AE%E5%A4%8D/","excerpt":"","text":"WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!重置阿里云服务器后，使用Mac终端ssh连接服务器时出错，报错如下解决措施如下看到日志中有一句 1Add correct host key in &#x2F;Users&#x2F;cby&#x2F;.ssh&#x2F;known_hosts to get rid of this message. 以编辑器的方式进入 ~/.ssh/known_hosts 此文件 1vim ~&#x2F;.ssh&#x2F;known_hosts 找到与服务器相对应ip的行，删除此行即可","categories":[],"tags":[]},{"title":"基于ECS搭建云博客","slug":"基于ECS搭建云博客","date":"2021-01-05T10:34:23.000Z","updated":"2021-01-05T10:34:42.968Z","comments":true,"path":"2021/01/05/基于ECS搭建云博客/","link":"","permalink":"https://bingyuchan.github.io/2021/01/05/%E5%9F%BA%E4%BA%8EECS%E6%90%AD%E5%BB%BA%E4%BA%91%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装Apache HTTP12yum -y install httpd httpd-manual mod_ssl mod_perl mod_auth_mysqlsystemctl start httpd.service 安装并启动MySQL12345678910wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-serversystemctl start mysqld.servicesystemctl status mysqld.servicegrep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.logmysql -uroot -pALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;NewPassWord1.&#39;;create database wordpress; show databases; 安装php123yum -y install php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imapecho &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; &#x2F;var&#x2F;www&#x2F;html&#x2F;phpinfo.phpsystemctl restart httpd wordpress安装配置1234567891011121314yum -y install wordpress# 进入&#x2F;usr&#x2F;share&#x2F;wordpress目录cd &#x2F;usr&#x2F;share&#x2F;wordpress # 修改路径。 ln -snf &#x2F;etc&#x2F;wordpress&#x2F;wp-config.php wp-config.php # 查看修改后的目录结构。 ll# 在Apache的根目录&#x2F;var&#x2F;www&#x2F;html下，创建一个wp-blog文件夹mkdir &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog mv * &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;sed -i &#39;s&#x2F;database_name_here&#x2F;wordpress&#x2F;&#39; &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.php sed -i &#39;s&#x2F;username_here&#x2F;root&#x2F;&#39; &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.php sed -i &#39;s&#x2F;password_here&#x2F;NewPassWord1.&#x2F;&#39; &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.phpcat -n &#x2F;var&#x2F;www&#x2F;html&#x2F;wp-blog&#x2F;wp-config.phpsystemctl restart httpd","categories":[],"tags":[]}],"categories":[],"tags":[]}